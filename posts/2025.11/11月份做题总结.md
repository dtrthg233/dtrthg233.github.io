# November

## 11.1

西欸死批

## 11.2

### [P14362 [CSP-S 2025] 道路修复 / road（民间数据）](https://www.luogu.com.cn/problem/P14362)

~~唉.....~~

读完题发现是建边优化。k很小，可以直接枚举。n不大，发现原图的边中有用的就mst的n-1条边，想到这就做完了。

### [P11361 [NOIP2024] 编辑字符串](https://www.luogu.com.cn/problem/P11361)

这题骗80分很合适，满分的性价比不高。

部分分：
1. 暴力
2. s1就一个字符，直接统计
3. t1=t2，那对应的每段匹配
4. 把两个0映射到一条线上，然后一段段做。

上述这些都80分了

### [P11363 [NOIP2024] 树的遍历](https://www.luogu.com.cn/problem/P11363)

个人认为和组合数学关系不大，用dp推来的更得心应手。

## 11.8~11.10

模拟赛

### [P11840 [USACO25FEB] Vocabulary Quiz S](https://www.luogu.com.cn/problem/P11840)

见noip模拟赛总结

## 11.11

死了。

## 11.12

### 11.9模拟赛T2

嗯补掉了。

注意是 `m*(x-1)+y` 而不是 `n*(x-1)+y`

同块内可达

### 二分求LIS

温故而知新。

首先观察朴素dp的状态设计：`f[i]` 表示以 `num[i]` 为结尾的LIS。

这样每次不可避免的要扫一遍前面的 `num`，考虑维度变换。

于是有：`f[i]` 表示LIS长度为 i 时，结尾最小的数

`f[i]` 的单调性显然，于是使转移能在 `logn` 完成。

具体的，对于 `a[i]`，如果能贡献LIS就贡献，否则找出第一个大于等于 `a[i]` 的数，然后贪心替换

所以为什么不能用`upper_bound`

因为相当于允许相等的数加长度了。如 12323：

lower_bound: 1 2 3
upper_bound  1 2 2

g可以这样子被污染，于是就有问题了

```cpp
      memset(g,0x3f,sizeof(g));
		g[1]=a[1];
		int len=1;
		fo(i,2,n)
		{
			if(a[i]>g[len]) g[++len]=a[i];
			else 
			{
			    int pos=lower_bound(g+1,g+len+1,a[i])-g;
			    g[pos]=a[i];
			}
		}
		cout<<len<<endl;
```

## 11.13

### [P3959 [NOIP 2017 提高组] 宝藏](https://www.luogu.com.cn/problem/P3959)

状压dp板子。

第一眼会先到MST，但发现选择会影响剩余边的边权，于是不行。

第二眼发现n小的离谱，于是有了指数级的资本。

考虑记搜。设 `f[1<<N]` 表示在点的访问情况为 `100..01010` 时，最小的代价。发现转移时需要深度，于是再把深度设上去，即：

`f[N][1<<N]` 表示表示在深度为 `n`，点的访问情况为 `100..01010` 时，最小的代价。

接下来会二进制基本操作就行了。

一件省心的事：如果转移时转到浅的点，深度的设定会自动pass掉这种情况，应该是出题人有意为之的”分层“约束。

附：二进制枚举子集（**并不能枚举到空集**）

```cpp
fo(i,1,(1<<n)-1)
	for(int j=i;j;j=(j-1)&i)
	{
		...
	}
```

趣事：转移时忘把自环判了+多转移了一层，但我又忘了判只有一个点的情况，于是初值进转移了，就对了（

其实自环也不用判，但为了鲁棒性还是判比较规范。

## 11.14

操你妈又发作。

