---
title: 自用模板
tags: [模板,总结]
# categories: []
date: 2025.10.28
# description: 描述
# articleGPT: 总结，在文章界面会有个假的 AI 输出
---

# 模板总结

自用

## 编译器/对拍

### 缺省源

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=;

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	
	return 0;
}
/*
in1:

out1:

*/

/*
remember:

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct Hsh
{
	ull operator () (const ull&x)const
	{
		static const ull r=rnd();
		return x^r;
	}
};
unordered_map <ull,ull,Hsh> val;

next_permutation
*/
```

## 数据结构

### 并查集

见 图论-kruskal

### 可删堆

一个原堆一个删堆，当两堆顶相等时同时弹出，懒着写了

### 对顶堆

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=-1;
priority_queue <int,vector<int> > q1;
priority_queue <int,vector<int>,greater<int> > q2;
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n;cin>>n;
	int meow;cin>>meow;
	cout<<meow<<endl; q1.push(meow);
	fo(i,2,n)
	{
		int x;cin>>x;
		if(x>q1.top()) q2.push(x);
		else q1.push(x);
		while(abs((int)q1.size()-(int)q2.size())>1) 
		{
			if(q1.size()>q2.size()) {q2.push(q1.top()); q1.pop();}
			else {q1.push(q2.top()); q2.pop();}
		}
		if(i&1) 
		{
			if(q1.size()>q2.size()) cout<<q1.top()<<endl;
			else cout<<q2.top()<<endl;
		}
	}
	return 0;
}

```

### 线段树

注意，用区间改省掉 `build` 函数会导致常数变大。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
#define lc mid<<1
#define rc mid<<1|1
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=1e5+10;
ll tr[N<<1],lzy1[N<<1],lzy2[N<<1],mod;
//1:times 2:add
void push_down(int l,int r,int p)
{
	int mid=l+r>>1;
	tr[lc]*=lzy1[p];
	tr[lc]+=lzy2[p]*(mid-l+1);
	lzy1[lc]*=lzy1[p];
	lzy2[lc]*=lzy1[p];
	lzy2[lc]+=lzy2[p];
	
	tr[rc]*=lzy1[p];
	tr[rc]+=lzy2[p]*(r-mid);
	lzy1[rc]*=lzy1[p];
	lzy2[rc]*=lzy1[p];
	lzy2[rc]+=lzy2[p];
	
	lzy1[p]=1; lzy2[p]=0;
	lzy1[lc]%=mod; lzy2[lc]%=mod; tr[lc]%=mod;
	lzy1[rc]%=mod; lzy2[rc]%=mod; tr[rc]%=mod;
}
void updta1(int l,int r,int p,int L,int R,ll k)
{
	if(L<=l && r<=R) 
	{
		lzy2[p]*=k; lzy2[p]%=mod;
		lzy1[p]*=k; lzy1[p]%=mod;
		tr[p]*=k; tr[p]%=mod;
		return ;
	}
	push_down(l,r,p);
	int mid=l+r>>1;
	if(L<=mid) updta1(l,mid,lc,L,R,k);
	if(mid<R) updta1(mid+1,r,rc,L,R,k);
	tr[p]=tr[lc]+tr[rc];
}
void updta2(int l,int r,int p,int L,int R,ll k)
{
	if(L<=l && r<=R)
	{
		lzy2[p]+=k; lzy2[p]%=mod;
		tr[p]+=(r-l+1)*k; tr[p]%=mod;
		return ;
	}
	push_down(l,r,p);
	int mid=l+r>>1;
	if(L<=mid) updta2(l,mid,lc,L,R,k);
	if(mid<R) updta2(mid+1,r,rc,L,R,k);
	tr[p]=tr[lc]+tr[rc];
}
ll query(int l,int r,int p,int L,int R)
{
	if(L<=l && r<=R) return tr[p];
	push_down(l,r,p);
	ll mid=l+r>>1,res=0;
	if(L<=mid) res+=query(l,mid,lc,L,R);
	if(mid<R)  res+=query(mid+1,r,rc,L,R);
	return res%mod;
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	ll n,Q;cin>>n>>Q>>mod;
	fo(i,1,n) 
	{
		int x;cin>>x;
		updta2(1,n,1,i,i,x);
	}
	while(Q--)
	{
		ll op,x,y;cin>>op>>x>>y;
		if(op==1)
		{
			ll k;cin>>k;
			updta1(1,n,1,x,y,k);
		}
		if(op==2)
		{
			ll k;cin>>k;
			updta2(1,n,1,x,y,k);
		}
		if(op==3) cout<<query(1,n,1,x,y)<<endl;
	}
	return 0;
}
```

### ST表

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=1e5+10;
int f[N][35],lg[N];
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,T;cin>>n>>T;
	fo(i,1,n) cin>>f[i][0];
	fo(i,2,n) lg[i]=lg[i>>1]+1;
	fo(j,1,25)
		for(int i=1;i+(1<<(j-1))-1<=n;++i)
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
	while(T--)
	{
		int l,r;cin>>l>>r;
		int stp=lg[r-l+1];
		cout<<max(f[l][stp],f[r-(1<<stp)+1][stp])<<endl;
	}
	return 0;
}
```

### 单调队列

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=1e6+10;
int q[N],a[N];
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,k;cin>>n>>k;
	fo(i,1,n) cin>>a[i];
	int h=1,t=0;
	fo(i,1,n)
	{
		while(h<=t && q[h]<i-k+1) ++h;
		while(h<=t && a[q[t]]>a[i]) --t;
		q[++t]=i;
		if(i>=k) cout<<a[q[h]]<<' ';
	}
	cout<<endl;
	memset(q,0,sizeof(q));
	h=1,t=0;
	fo(i,1,n)
	{
		while(h<=t && q[h]<i-k+1) ++h;
		while(h<=t && a[q[t]]<a[i]) --t;
		q[++t]=i;
		if(i>=k) cout<<a[q[h]]<<' ';
	}
	cout<<endl;
	return 0;
}
```

### 单调栈

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=3e6+10;
int a[N],stk[N],ans[N],top;
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n;cin>>n;
	fo(i,1,n)
	{
		cin>>a[i];
		while(a[stk[top]]<a[i] && top)
		{
			ans[stk[top]]=i;
			--top;
		}
		stk[++top]=i;
	}
	fo(i,1,n) cout<<ans[i]<<' ';
	cout<<endl;
	return 0;
}
```

> 就跟单调队列差不多。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。相比较，实际上单调栈用的虽然少一些，但是比单调队列更加灵活多变。  ——FjswYuzu

| 容器 | 存储内容 | Key 是否唯一 | Value 是否存在 | 核心用途 | 比喻 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `set` | Key | **是** | **否** | 检查存在性、去重、排序 | 签到表 |
| `map` | Key-Value Pair | **是** | **是** | 建立 Key 到 Value 的映射 | 通讯录 |
| `multiset` | Key | **否** | **否** | 排序、并统计每个元素出现次数| 投票箱 |
| `multimap` | Key-Value Pair | **否** | **是** | 建立一个 Key 到**多个** Value 的映射 | 一个作者的多本书 |

### 倍增LCA

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=5e5+10;
vector <int> no[N];
int dep[N],f[N][35],n;
void dfs(int now,int fat)
{
	f[now][0]=fat;
	dep[now]=dep[fat]+1;
	for(auto nxt : no[now]) 
	{
		if(nxt==fat) continue;
		dfs(nxt,now);
	}
}
void init()
{
	fo(j,1,25)
		fo(i,1,n)
			f[i][j]=f[f[i][j-1]][j-1];
}
int lca(int u,int v)
{
	if(dep[u]<dep[v]) swap(u,v);
	of(i,25,0)
		if(dep[f[u][i]]>=dep[v]) u=f[u][i];
	if(u==v) return u;
	of(i,25,0)
		if(f[u][i]!=f[v][i]) {u=f[u][i]; v=f[v][i];}
	return f[u][0];
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int Q,s;cin>>n>>Q>>s;
	fo(i,1,n-1)
	{
		int u,v;cin>>u>>v;
		no[u].P_B(v); no[v].P_B(u);
	}
	dfs(s,s);
	init();
	while(Q--)
	{
		int x,y;cin>>x>>y;
		cout<<lca(x,y)<<endl;
	}
	return 0;
}
```


## 图论

### MST之kruskal

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=5010,M=2e5+10;
int fa[N];
struct Edge 
{
	int u,v,w;
}e[M];
int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
bool cmp(Edge a,Edge b) {return a.w<b.w;}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,m;cin>>n>>m;
	fo(i,1,m) cin>>e[i].u>>e[i].v>>e[i].w;
	sort(e+1,e+m+1,cmp);
	fo(i,1,n) fa[i]=i;
	int ans=0;
	fo(i,1,m)
	{
		int u=e[i].u,v=e[i].v,w=e[i].w;
		int fa_u=find(u),fa_v=find(v);
		if(fa_u!=fa_v)
		{
			ans+=w;
			fa[fa_u]=fa_v;
		}
	}
	bool flag=1;
	fo(i,2,n) if(find(i)!=find(i-1)) {flag=0; break;}
	if(flag) cout<<ans<<endl;
	else cout<<"orz"<<endl;
	return 0;
}
```

### 迪杰斯特拉

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=1e5+10,M=2e5+10;
struct Node {int v,w;};
vector <Node> no[N];
int dis[N];
bool vis[N];
void dij(int s)
{
	memset(dis,0x3f,sizeof(dis)); dis[s]=0;
	priority_queue <pair<int,int> > q;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int now=q.top().second; q.pop();
		if(vis[now]) continue; vis[now]=1;
		for(auto _ : no[now])
		{
			int val=_.w,nxt=_.v;
			if(dis[nxt]>dis[now]+val) 
			{
				dis[nxt]=dis[now]+val;
				q.push({-dis[nxt],nxt});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,m,s;cin>>n>>m>>s;
	fo(i,1,m)
	{
		int u,v,w;cin>>u>>v>>w;
		no[u].P_B({v,w});
	}
	dij(s);
	fo(i,1,n) cout<<dis[i]<<' ';
	cout<<endl;
	return 0; 
}
```

### spfa

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=1e5+10,M=2e5+10;
struct Node {int v,w;};
vector <Node> no[N];
int dis[N];
bool vis[N];
void spa(int s)
{
	memset(dis,0x3f,sizeof(dis)); dis[s]=0;
	queue <int> q;
	q.push(s); vis[s]=1;
	while(!q.empty())
	{
		int now=q.front(); vis[now]=0;
		q.pop();
		for(auto _ : no[now])
		{
			int val=_.w,nxt=_.v;
			if(dis[nxt]>dis[now]+val) 
			{
				dis[nxt]=dis[now]+val;
				if(!vis[nxt]) q.push(nxt);
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,m,s;cin>>n>>m>>s;
	fo(i,1,m)
	{
		int u,v,w;cin>>u>>v>>w;
		no[u].P_B({v,w});
	}
	spa(s);
	fo(i,1,n)
	{
		if(dis[i]==inf) cout<<(1<<31)-1<<' ';
		else cout<<dis[i]<<' ';
	}
	cout<<endl;
	return 0; 
}
```

### floyd

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=110;
int f[N][N];
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n,m;cin>>n>>m;
	memset(f,0x3f,sizeof(f));
	fo(i,1,n) f[i][i]=0;
	fo(i,1,m)
	{
		int u,v,w;cin>>u>>v>>w;
		f[u][v]=f[v][u]=min(f[u][v],w);
	}
	fo(i,1,n)
		fo(x,1,n)
			fo(y,1,n) f[x][y]=min(f[x][y],f[x][i]+f[i][y]);
	fo(i,1,n)
	{
		fo(j,1,n) cout<<f[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```

### spfa判负环

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=2010,M=6010;
struct Node {int v,w;};
vector <Node> no[N];
int cnt[N],dis[N],n,m;
bool vis[N],flag=1;
void init()
{
	memset(cnt,0,sizeof(cnt));
	flag=1;
	vector <Node> no2[N];
	fo(i,0,2005) no[i]=no2[i];
	return ;
}
void spfa(int s)
{
	memset(dis,0x3f,sizeof(dis)); dis[s]=0;
	memset(vis,0,sizeof(vis));
	queue <int> q;
	q.push(s); vis[s]=1;
	while(!q.empty())
	{
		int now=q.front(); q.pop();
		vis[now]=0;
		for(auto _ : no[now])
		{
			int nxt=_.v,val=_.w;
			if(dis[nxt]>dis[now]+val)
			{
				dis[nxt]=dis[now]+val;
				if(!vis[nxt]) {q.push(nxt); vis[nxt]=1;}
				cnt[nxt]=cnt[now]+1;
				if(cnt[nxt]>=n) {flag=0; return ;}
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int T;cin>>T;
	while(T--)
	{
		init();
		cin>>n>>m;
		fo(i,1,m)
		{
			int u,v,w;cin>>u>>v>>w;
			if(w>=0) {no[u].P_B({v,w}); no[v].P_B({u,w});}
			else no[u].P_B({v,w});
		}
		spfa(1);
		if(!flag) cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}
	return 0;
}
```

## 杂项/常数

### __int128 & 快读快写

https://www.luogu.com.cn/record/243851367

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll __int128
#define P_B push_back
#define gc getchar
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=-1;
ll read()
{
	ll w=0,f=1; char ch=gc();
	while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=gc();}
	while(ch>='0' && ch<='9') {w=w*10+ch-'0'; ch=gc();}
	return w*f;
}
void print(ll x)
{
	if(x<0) {putchar('-'); x=-x;}
	if(x<10) putchar(x+'0');
	else {print(x/10); putchar('0'+x%10);}
}
ll gcd(ll a,ll b) {if(!b) return a; return gcd(b,a%b);}
ll lcm(ll a,ll b) {return a*b/gcd(a,b);}
int main()
{
	int T=read();
	while(T--)
	{
		ll n=read(),a=read(),b=read(),c=read();
		ll ans1=n/a-n/lcm(a,b);
		ll ans2=n/c;
		ll ans=ans1+ans2-(n/lcm(a,c)-n/lcm(lcm(a,b),c));
		print(ans); puts("");
	}
	return 0;
}
```

### 字符串hash

```cpp
#include <bits/stdc++.h>11
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=10010;
const int mod=1e9+7;
const int base=13331;
int val[N]; 
string x;
void calc(int id)
{
	int len=x.size();
	fo(i,0,len-1) val[id]=(val[id]*base%mod+(int)x[i])%mod;
}
int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int n;cin>>n;
	fo(i,1,n)
	{
		cin>>x;
		calc(i);
	}
	sort(val+1,val+n+1);
	int ans=1;
	fo(i,2,n) if(val[i]!=val[i-1]) ++ans;
	cout<<ans<<endl;
	return 0;
}
```

### 普通hash（`unodereded_map` 防卡版）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define P_B push_back
#define gc getchar
#define ull unsigned long long
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int N=5e6+10;
ull read()
{
	ull w=0,f=1; char ch=gc();
	while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=gc();}
	while(ch>='0' && ch<='9') {w=w*10+ch-'0'; ch=gc();}
	return w*f;
}
void print(ull x)
{
	if(x<0) {putchar('-'); x=-x;}
	if(x<10) putchar(x+'0');
	else {print(x/10); putchar(x%10+'0');}
}
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct Hsh
{
	ull operator () (const ull&x)const
	{
		static const ull r=rnd();
		return x^r;
	}
};
unordered_map <ull,ull,Hsh> val;
int main()
{
	int n=read();
	ull ans=0;
	fo(i,1,n)
	{
		ull x=read(),y=read();
		ans+=val[x]*i;
		val[x]=y;
	}
	print(ans); puts("");
	return 0;
}
```
